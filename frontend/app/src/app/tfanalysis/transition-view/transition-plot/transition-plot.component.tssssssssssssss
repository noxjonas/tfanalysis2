import { Component, OnInit, ElementRef, ViewEncapsulation, Input, SimpleChanges, OnChanges } from '@angular/core';
import * as d3 from 'd3';
import {TransitionData} from "../../common.service";

@Component({
  selector: 'app-transition-plot',
  encapsulation: ViewEncapsulation.None,
  templateUrl: './transition-plot.component.html',
  styleUrls: ['./transition-plot.component.css']
})
export class TransitionPlotComponent implements OnInit, OnChanges {
  @Input() transitionData!: TransitionData[];

  transitionTime = 1000;
  xmax = 100;
  ymax = 20000;
  hticks = 60;
  data: number[] = [];
  showLabel = 1;
  hostElement; // Native element hosting the SVG container
  svg:any; // Top level SVG element
  g:any; // SVG Group element
  colorScale:any; // D3 color provider
  x:any; // X-axis graphical coordinates
  y:any; // Y-axis graphical coordinates
  colors = d3.scaleOrdinal(d3.schemeCategory10);
  bins:any; // Array of frequency distributions - one for each area chaer
  paths:any; // Path elements for each area chart
  area:any; // For D3 area function
  histogram:any; // For D3 histogram function

  constructor(private elRef: ElementRef) {
    this.hostElement = this.elRef.nativeElement;
  }

  ngOnInit() {
    this.createChart([10, 15, 20])
  }

  ngOnChanges(changes: SimpleChanges) {
    console.log('data from the plot component', this.transitionData)
    if (changes.data) {
      console.log('on changes data from the plot component', this.transitionData)

    }
  }

  private createChart(data: number[]) {

    // this.removeExistingChartFromParent();



    // this.addGraphicsElement();

    let data2 = [
      {country:"USA", gold:10, silver:20},
      {country:"China", gold:20, silver:30},
      {country:"India", gold:200, silver:50},
      {country:"Russia", gold:25, silver:80},
      {country:"Germany", gold:10, silver:20},
      {country:"UK", gold:10, silver:75},
      {country:"France", gold:10, silver:70},
      {country:"UAE", gold:30, silver:10},
      {country:"Canada", gold:10, silver:15}
    ]

    // var svg = d3.select("body")
    //   .append("svg")
    //   .attr("width", 250)
    //   .attr("height", 250)
    let width = 1000
    let height = 750
    let margin = 50

    this.svg = d3.select(this.hostElement).append('svg')
      .attr('width', '100%')
      .attr('height', '100%')
      .attr('viewBox', '0 0 ' + 200 + ' ' + 100);

    this.g = this.svg.append("g")
      .attr("transform", "translate(0,0)");

    this.x = d3.scaleLinear()
      .domain([0, this.xmax])
      .range([0, 100]);
    this.g.append('g')
      .attr('transform', 'translate(0,90)')
      .attr("stroke-width", 0.5)
      .call(d3.axisBottom(this.x).tickSize(0).tickFormat(<any>''));

    this.g.append('g')
      .attr('transform', 'translate(0,90)')
      .style('font-size', '6')
      .style("stroke-dasharray", ("1,1"))
      .attr("stroke-width", 0.1)
      .call(d3.axisBottom(this.x).ticks(10).tickSize(-80));

    this.y = d3.scaleLinear()
      .domain([0, this.ymax])
      .range([90, 10]);
    this.g.append('g')
      .attr('transform', 'translate(30,0)')
      .attr("stroke-width", 0.5)
      .call(d3.axisLeft(this.y).tickSize(0).tickFormat(<any>''));
    this.g.append('g')
      .attr('transform', 'translate(30,0)')
      .style("stroke-dasharray", ("1,1"))
      .attr("stroke-width", 0.1)
      .call(d3.axisLeft(this.y).ticks(4).tickSize(-140))
      .style('font-size', '6');


    // // let scaleX = d3.scaleLinear()
    // //   .domain([0, 100])
    // //   .range([0, width - 2*margin]);
    //
    // let scaleY = d3.scaleLinear()
    //   .domain([0, 20000])
    //   .range([0, height - 2*margin]);
    //
    // //let axisX = d3.axisTop(scaleX);
    // let axisY = d3.axisLeft(scaleY);
    //
    // this.g.append('g').call(axisY);
    // //this.g.append('g').call(axisX);

    //let marks = d3.select('svg').select('.vis .marks');
    //console.log('these marks', marks)

    let seriesNames = this.transitionData.map(a => a.pos);


    let newData:any = []
      this.transitionData.forEach(samples => {
        samples.scatter_raw.x.forEach(
          (x, index) => {
            newData.push({
              pos: samples.pos,
              x: x,
              y: samples.scatter_raw.y[index]
            })
          }
        )
      }
    )



    console.log('transformedData', newData)

    // this.svg.selectAll("circle")
    //   .data(newData).enter()
    //   .append("circle")
    //   .attr("cx", function(d: any) {return d.x})
    //   .attr("cy", function(d: any) {return d.y})
    //   .attr("r", 4)
      // .attr("fill", function(d: any) {
      //   return "rgb("+d.gold+","+d.silver+",0)"
      // })

    // this.svg.selectAll("text")
    //   .data(data2).enter()
    //   .append("text")
    //   .attr("x", function(d: any) {return d.gold+10})
    //   .attr("y", function(d: any) {return d.silver+4})
    //   .text(function(d: any) {return d.country})
    //   .attr("font-size", "10px")

  }

  private setChartDimensions() {
    let viewBoxHeight = 200;
    let viewBoxWidth = 300;
    this.svg = d3.select(this.hostElement).append('svg')
      .attr('width', '1100px')
      .attr('height', '1100px')
      //.attr('viewBox', '0 0 ' + viewBoxWidth + ' ' + viewBoxHeight);
  }

  private addGraphicsElement() {
    this.g = this.svg.append("g")
      .attr("transform", "translate(40,40)");
  }

  private removeExistingChartFromParent() {
    // !!!!Caution!!!
    // Make sure not to do;
    //     d3.select('svg').remove();
    // That will clear all other SVG elements in the DOM
    d3.select(this.hostElement).select('svg').remove();
  }
}

import {Component, OnInit, Input, OnChanges, SimpleChanges, NgZone, AfterViewInit,Inject, PLATFORM_ID, ViewChild, ElementRef} from '@angular/core';
import {isPlatformBrowser} from "@angular/common";
import {
  ChartDataSets,
  ChartType,
  ChartOptions,
  Scriptable,
  PointStyle,
  ChartColor,
  PositionType,
  ChartLegendLabelItem, ChartLegendLabelOptions
} from 'chart.js';
import { Label } from 'ng2-charts';
import {CommonService, TransitionData} from "../../common.service";
import {SampleInfo} from "../../sample-info/sample-info.component";

// amCharts imports
import * as am4core from '@amcharts/amcharts4/core';
import * as am4charts from '@amcharts/amcharts4/charts';
import am4themes_animated from '@amcharts/amcharts4/themes/animated';

//TODO: For speed consider simplifiedProcessing attribute of series

interface RegularTransitionSeriesData {
  // scatter_raw_x: number,
  // scatter_raw_y: number,
  scatter_regular_x: number,
  scatter_regular_y: number,
  scatter_normal_y: number,
  scatter_smooth_y: number,
  scatter_first_der_y: number,
}

interface RegularGenericTransitionData {
  x: number,
  y: number,
}

interface xy {
  x: number;
  y: number;
}

class SeriesData {
  constructor(
    data: {
      x: number;
      y: number;
    }[],
    label: string,
  ) {}
}

class DefaultColours {
  grey = ['#7f7f7f', '#a8a8a8', '#535353', '#939393', '#696969'];
  blue = ['#1f77b4', '#7ba2cd', '#204e74', '#568cc1', '#216293'];
  orange = ['#ff7f0e', '#ffaf71', '#a45415', '#ff9848', '#d06913'];
  green = ['#2ca02c', '#7ec073', '#256822', '#5ab051', '#298427'];
  red = ['#d62728', '#ef7b6a', '#8b221d', '#e45648', '#b02623'];
  purple = ['#9467bd', '#b998d3', '#61457a', '#a77fc8', '#7a569b'];
  brown = ['#8c564b', '#b48b83', '#5c3a33', '#a07066', '#74483f'];
  pink = ['#e377c2', '#efa6d6', '#e98fcc', '#914f7d', '#b9639f'];
  yellow = ['#bcbd22', '#d7d275', '#7a7a1f', '#cac850', '#9a9b21'];
  teal = ['#17becf', '#84d4df', '#227a85', '#5dc9d7', '#209ca9'];
}
interface GenericColours {
  [index: string]: any;
}

interface SeriesColours {
  pos: string,
  color: string,
  [index: string]: string;
}

// options.elements.point should allow me to set general params for all points


@Component({
  selector: 'app-transition-plot',
  templateUrl: './transition-plot.component.html',
  styleUrls: ['./transition-plot.component.css']
})
export class TransitionPlotComponent implements AfterViewInit, OnChanges {
  @Input() transitionData!: TransitionData[];
  @Input() plotDataType!: string;
  @Input() filterPosArr!: string[];
  @Input() samples: SampleInfo[] = [];

  @ViewChild('chartElement') chartElement: ElementRef<HTMLElement>;


  defaultColours = <GenericColours>{
    // Arrays defining each base colour must have identical lengths
    grey : ['#7f7f7f', '#a8a8a8', '#535353', '#939393', '#696969'],
    blue : ['#1f77b4', '#7ba2cd', '#204e74', '#568cc1', '#216293'],
    orange : ['#ff7f0e', '#ffaf71', '#a45415', '#ff9848', '#d06913'],
    green : ['#2ca02c', '#7ec073', '#256822', '#5ab051', '#298427'],
    red : ['#d62728', '#ef7b6a', '#8b221d', '#e45648', '#b02623'],
    purple : ['#9467bd', '#b998d3', '#61457a', '#a77fc8', '#7a569b'],
    brown : ['#8c564b', '#b48b83', '#5c3a33', '#a07066', '#74483f'],
    pink : ['#e377c2', '#efa6d6', '#e98fcc', '#914f7d', '#b9639f'],
    yellow : ['#bcbd22', '#d7d275', '#7a7a1f', '#cac850', '#9a9b21'],
    teal : ['#17becf', '#84d4df', '#227a85', '#5dc9d7', '#209ca9'],
  }
  seriesColours: SeriesColours[] = [];
  private chart: am4charts.XYChart;


  public scatterChartData: ChartDataSets[] = [];
  public scatterChartType: ChartType = 'scatter';

  constructor(@Inject(PLATFORM_ID) private platformId: any, private zone: NgZone,
    private commonService: CommonService) {
    commonService.transitionsProcessed$.subscribe(data => this.ngAfterViewInit());
  }
  // Run the function only in the browser
  browserOnly(f: () => void) {
    if (isPlatformBrowser(this.platformId)) {
      this.zone.runOutsideAngular(() => {
        f();
      });
    }
  }
  ngAfterViewInit() {

    this.browserOnly(() => {
      //am4core.useTheme(am4themes_animated);

      let chart = am4core.create(this.chartElement.nativeElement, am4charts.XYChart);

      chart.paddingRight = 20;

      let data = [];
      let visits = 10;
      for (let i = 1; i < 366; i++) {
        visits += Math.round((Math.random() < 0.5 ? 1 : -1) * Math.random() * 10);
        data.push({ date: i*2, name: "name" + i, value: visits });
      }

      //chart.data = data;

      let xAxis = chart.xAxes.push(new am4charts.ValueAxis());
      xAxis.renderer.minWidth = 35;
      xAxis.keepSelection = true;

      let yAxis = chart.yAxes.push(new am4charts.ValueAxis());
      yAxis.tooltip.disabled = true;
      yAxis.renderer.minWidth = 35;



      this.transitionData.forEach((data, i) => {
        //let x = series[selectedX]
        //let y = series[selectedY]
        // scatter_regular_x: number,
        //   scatter_regular_y: number,
        //   scatter_normal_y: number,
        //   scatter_smooth_y: number,
        //   scatter_first_der_y: number,
        const zip = (a: number[], b: number[], c: number[], d: number[], e: number[]) =>
          a.map((k: number, i: number) => <RegularTransitionSeriesData>{
            scatter_regular_x: k,
            scatter_regular_y: b[i],
            scatter_normal_y: c[i],
            scatter_smooth_y: d[i],
            scatter_first_der_y: e[i],
          });

        const zipData = (a: number[], b: number[]) =>
          a.map((k: number, i: number) => <RegularGenericTransitionData>{
            x: k,
            y: b[i],
          });

        let regularData = zipData(data.scatter_regular_x, data.scatter_regular_y);
        let normalData = zipData(data.scatter_regular_x, data.scatter_normal_y);
        let smoothData = zipData(data.scatter_regular_x, data.scatter_smooth_y);
        let firstDerData = zipData(data.scatter_regular_x, data.scatter_first_der_y);

        let regularSeries = chart.series.push(new am4charts.LineSeries());
        regularSeries.data = regularData
        regularSeries.dataFields.valueX = "x";
        regularSeries.dataFields.valueY = "y";
        regularSeries.dummyData = "regular";
        regularSeries.hidden = false;
        regularSeries.showOnInit = false;

        let normalSeries = chart.series.push(new am4charts.LineSeries());
        normalSeries.data = normalData
        normalSeries.dataFields.valueX = "x";
        normalSeries.dataFields.valueY = "y";
        normalSeries.dummyData = "normal";
        normalSeries.hidden = true;
        normalSeries.showOnInit = false;

        let smoothSeries = chart.series.push(new am4charts.LineSeries());
        smoothSeries.data = smoothData
        smoothSeries.dataFields.valueX = "x";
        smoothSeries.dataFields.valueY = "y";
        smoothSeries.dummyData = "smooth";
        smoothSeries.hidden = true;
        smoothSeries.showOnInit = false;

        let firstDerSeries = chart.series.push(new am4charts.LineSeries());
        firstDerSeries.data = firstDerData
        firstDerSeries.dataFields.valueX = "x";
        firstDerSeries.dataFields.valueY = "y";
        firstDerSeries.dummyData = "first_der";
        firstDerSeries.hidden = true;
        firstDerSeries.showOnInit = false;



        // let series = chart.series.push(new am4charts.LineSeries());
        // series.data = zip(
        //   data.scatter_regular_x, data.scatter_regular_y, data.scatter_normal_y, data.scatter_smooth_y, data.scatter_first_der_y
        // );
        // series.dataFields.valueX = "scatter_regular_x";
        // series.dataFields.valueY = "scatter_regular_y";
        // series.tooltipText = data.pos+" is the pos";
        // series.showOnInit = false;
        // series.disabled = false;
      });


      chart.cursor = new am4charts.XYCursor();

      chart.scrollbarX = new am4charts.XYChartScrollbar();

      this.chart = chart;
    });
    //this.generateColors();
    //this.applyData();
  }
  ngOnDestroy() {
    // Clean up chart when the component is removed
    this.browserOnly(() => {
      if (this.chart) {
        this.chart.dispose();
      }
    });
  }

  ngOnChanges(changes: SimpleChanges) {
    console.log('These are the changes that are happening:', changes)
    // Separate into functions that do different things dependent on change
    if (changes.plotDataType) {
      console.log('property', this.chart.dataFields)
      this.changeDataFields()
      // update plot data
      //this.generateColors();
      //this.applyData();
    }
    if (changes.filterPosArr) {
      // react to changes in filters
    }
    if (changes.transitionData) {
      // apply changes when the data changes
      // i.e. remake the chart and colouring
    }
  }

  generateColors () {
    // Should colours be recalculated based on visible filters?
    // Probably yes, otherwise you can easily end up with very few distinct colours
    // Also, filtered samples will not be displayed, so I don't even have to change their colours
    // Remember to assign, white or any colour to the filtered out samples as this must have the same dimensions

    // Get displayed samples
    // @ts-ignore
    let displayedSamples: SampleInfo[] = this.samples.flatMap(x => this.filterPosArr.includes(x.pos) ? x : []);
    let displayedSamplesPos = displayedSamples.map(x => x.pos)

    // Check if grouping is used; i.e. there must be more than 1 group
    let groups = [...new Set(displayedSamples.map(x => x.group))].sort()
    console.log('groups', groups)
    if (groups.length < 2) {
      // just make simple array of colours
      let simpleColourArr = [];
      for (let i = 0; i < this.defaultColours[Object.keys(this.defaultColours)[0]].length; i++) {
        for (let prop in this.defaultColours) {
          if (Object.prototype.hasOwnProperty.call(this.defaultColours, prop)) {
            simpleColourArr.push(this.defaultColours[prop][i])
          }
        }
      }
      // multiply this array to make sure there are enough colours to cover all samples
      let extendedColourArr: string[] = []
      for (let i = 0; i <= Math.ceil( this.samples.length / simpleColourArr.length ); i++) {
        extendedColourArr.push(...simpleColourArr)
      }

      let offset = 0;
      this.seriesColours = this.samples.map((x, i) => {
        if (displayedSamplesPos.includes(x.pos)) {
          return {pos: x.pos, color: extendedColourArr[i+offset]}
        } else {
          offset += 1;
          return {pos: x.pos, color: '#ffffff'}
        }
      })

      console.log('colourMap', this.seriesColours)
    }



    // an array should be returned in same order and length as sample info, since pos will be used to map colour
    //  to both scatter points and the v-lines
  }


  // events
  public chartClicked({ event, active }: { event: MouseEvent, active: {}[] }): void {
    console.log(event, active);
  }

  public chartHovered({ event, active }: { event: MouseEvent, active: {}[] }): void {
    console.log(event, active);
  }

  changeDataFields() {
    // arr = ['raw', 'regular', 'smooth', 'normal', 'first_der']
    const {selectedX, selectedY} = (() => {
      if (this.plotDataType == 'raw') {
        return {selectedX: 'scatter_raw_x', selectedY: 'scatter_raw_y'}
      } else {
        return {selectedX: 'scatter_regular_x', selectedY: this.plotDataType}
      }
    }) ()
    console.log('selectedY', selectedY)

    // for (let yAxis of this.chart.yAxes) {
    //   console.log('yAxis one', yAxis.minY, yAxis.maxY)
    //   yAxis.renderer.maxY = 1;
    //   // yAxis. = 0;
    //   // yAxis.maxY = 1;
    //   this.chart.updateYAxis(yAxis.renderer)
    // }
    // assuming you have one value axis on the y axis:
    let valueAxis = this.chart.yAxes.getIndex(0);
    // @ts-ignore
    valueAxis.max = 1.05
    // @ts-ignore
    valueAxis.min = -0.05
    // make updates to the variable

    // // if you have multiple value axes:
    // this.chart.yAxes.each(function(valueAxis) {
    //   // make changes to each axis object
    // });


    for (let series of this.chart.series) {
      //console.log('series.dataFields', series.dataFields)
      series.hidden = series.dummyData != this.plotDataType;
      //series.dataFields.valueY = selectedY
      //series.reinit()
      //series.validateData()
      //series.valida
      //console.log(series.data)
    }
    //this.chart.validateData()
    //this.chart.validateData()

  //   let data: SeriesData[] = [];
  //
  //   this.transitionData.forEach((series, i) => {
  //     let x = series[selectedX]
  //     let y = series[selectedY]
  //     const zip = (a: number[], b: number[]) => a.map((k: number, i: number) => <xy>{x: k, y: b[i]});
  //     data.push(<SeriesData>{
  //       data: zip(x, y),
  //       label: series.pos,
  //       //pointRadius: 5,
  //       //fill: true,
  //       //borderColor: '#7f7f7f',
  //       //backgroundColor: '#7f7f7f',
  //       //borderWidth: 0,
  //       //pointStyle: 'circle',
  //       pointBorderColor: this.seriesColours[i].color,
  //       pointBackgroundColor: this.seriesColours[i].color,
  //       //pointHoverRadius: 5,
  //       pointHoverBackgroundColor: this.seriesColours[i].color
  //     })
  //   })
  //   this.scatterChartData = data
  }

}
